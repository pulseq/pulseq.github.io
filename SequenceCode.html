<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<meta name="keywords" content="MRI, magnetic resonance, imaging, MR, NMR, sequence">
<meta name="description" content="Open source pulse sequences for NMR and MRI">
<meta name="author" content="University Medical Center Freiburg">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<title>Open source pulse sequences: MATLAB class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customstyles.css" rel="stylesheet" type="text/css"/>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-32354347-3', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 1.5em;">
   <div id="projectname">Open source pulse sequences
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Easily create and share MR sequences</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="matlab.html"><span>MATLAB</span></a></li>
      <li><a href="annotated.html"><span>C++</span></a></li>
      <li><a href="https://github.com/pulseq/pulseq"><span>Source</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MATLAB class </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Sequence</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-04-30"><meta name="DC.source" content="Sequence.m"><style type="text/css">
html,body,div.content,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table.content th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table.content td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> Sequence &lt; handle
    <span class="comment">% Sequence   Generate sequences and read/write sequence files.</span>
    <span class="comment">% This class defines properties and methods to define a complete</span>
    <span class="comment">% MR sequence including RF pulses, gradients, ADC events, etc.</span>
    <span class="comment">%</span>
    <span class="comment">% The class provides an implementation of the open MR sequence format</span>
    <span class="comment">% defined by the Pulseq project.</span>
    <span class="comment">%   See http://pulseq.github.io/</span>
    <span class="comment">%</span>
    <span class="comment">% Sequence Properties:</span>
    <span class="comment">%    definitions - A list of custom definitions</span>
    <span class="comment">%</span>
    <span class="comment">% Sequence Methods:</span>
    <span class="comment">%    read - Load sequence from open MR sequence format</span>
    <span class="comment">%    write - Write sequence to open MR sequence format</span>
    <span class="comment">%</span>
    <span class="comment">% Sequence Static Methods:</span>
    <span class="comment">%    makeTrapezoid - Create a trapezoid gradient structure</span>
    <span class="comment">%</span>
    <span class="comment">% Examples:</span>
    <span class="comment">%</span>
    <span class="comment">% To read a sequence from file:</span>
    <span class="comment">%     read(seqObj,'my_sequences/gre.seq');</span>
    <span class="comment">%</span>
    <span class="comment">% To plot a sequence:</span>
    <span class="comment">%     plot(seqObj)</span>
    <span class="comment">%</span>
    <span class="comment">% See also   demoRead.m, demoWrite.m</span>
    <span class="comment">% Examples defining an MRI sequence and reading/writing files</span>
    <span class="comment">%</span>
    <span class="comment">% Kelvin Layton &lt;kelvin.layton@uniklinik-freiburg.de&gt;</span>

    <span class="keyword">properties</span>(Constant)
        RfRasterTime = 1e-6;
        GradRasterTime = 10e-6;
    <span class="keyword">end</span>

    <span class="comment">% Private properties</span>
    <span class="comment">%</span>
    <span class="keyword">properties</span>(GetAccess = public, SetAccess = private)
        definitions     <span class="comment">% Optional sequence definitions</span>

        blockEvents;    <span class="comment">% Event table (references to events)</span>
        rfLibrary;      <span class="comment">% Library of RF events</span>
        gradLibrary;    <span class="comment">% Library of gradient events</span>
        adcLibrary;     <span class="comment">% Library of ADC readouts</span>
        delayLibrary;   <span class="comment">% Library of delay events</span>
        shapeLibrary;   <span class="comment">% Library of compressed shapes</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> obj = Sequence()
            obj.definitions=containers.Map();
            obj.gradLibrary=containers.Map(<span class="string">'KeyType'</span>,<span class="string">'double'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
            obj.shapeLibrary=containers.Map(<span class="string">'KeyType'</span>,<span class="string">'double'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
            obj.rfLibrary=containers.Map(<span class="string">'KeyType'</span>,<span class="string">'double'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
            obj.adcLibrary=containers.Map(<span class="string">'KeyType'</span>,<span class="string">'double'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
            obj.delayLibrary=containers.Map(<span class="string">'KeyType'</span>,<span class="string">'double'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
        <span class="keyword">end</span>

        <span class="comment">% See read.m</span>
        read(obj,filename)

        <span class="comment">% See write.m</span>
        write(obj,filename)

        <span class="keyword">function</span> value=getDefinition(obj,key)
            <span class="comment">%getDefinition Return the values of custom definition.</span>
            <span class="comment">%   val=getDefinitions(seqObj,key) Return value of the</span>
            <span class="comment">%   definition specified by the key.</span>

            <span class="comment">%   These definitions can be added manually or read from the</span>
            <span class="comment">%   header of a sequence file defined in the sequence header.</span>
            <span class="comment">%   An empty array is return if the key is not defined.</span>
            <span class="comment">%</span>
            <span class="comment">%   See also setDefinition</span>
            <span class="keyword">if</span> isKey(obj.definitions,key)
                value = obj.definitions(key);
            <span class="keyword">else</span>
                value = [];
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> setDefinition(seqObj,key,val)
            <span class="comment">%setDefinition Modify a custom definition of the sequence.</span>
            <span class="comment">%   setDefinition(seqObj,def,val) Set the user definition 'key'</span>
            <span class="comment">%   to value 'val'. If the definition does not exist it will be</span>
            <span class="comment">%   created.</span>
            <span class="comment">%</span>
            <span class="comment">%   See also getDefinition</span>
            seqObj.definitions(key)=val;
        <span class="keyword">end</span>

        <span class="keyword">function</span> addBlock(obj,varargin)
            <span class="comment">%addBlock Add a new block to the sequence.</span>
            <span class="comment">%   addBlock(obj, blockStruct) Adds a sequence block with</span>
            <span class="comment">%   provided as a block struture</span>
            <span class="comment">%</span>
            <span class="comment">%   addBlock(obj, e1, e2, ...) Adds a block with multiple</span>
            <span class="comment">%   events e1, e2, etc.</span>
            <span class="comment">%</span>
            <span class="comment">%   See also  setBlock, makeAdc, makeTrapezoid, makeSincPulse</span>
            setBlock(obj,size(obj.blockEvents,1)+1,varargin{:});

        <span class="keyword">end</span>

        <span class="comment">%TODO: replacing blocks mid sequence can cause library indexing</span>
        <span class="comment">%issues, no longer run in order (ok?), unused library entries (can prune).</span>
        <span class="keyword">function</span> setBlock(obj,index,varargin)
            <span class="comment">%setBlock Replace sequence block.</span>
            <span class="comment">%   setBlock(obj, index, bStruct) Replace block at index with new</span>
            <span class="comment">%   block provided as block structure.</span>
            <span class="comment">%</span>
            <span class="comment">%   setBlock(obj, index, e1, e2, ...) Create a new block from</span>
            <span class="comment">%   events and store at position given by index.</span>
            <span class="comment">%</span>
            <span class="comment">%   The block or events are provides in uncompressed form and</span>
            <span class="comment">%   will be stored in a compressed, non-redundant internal</span>
            <span class="comment">%   libraries.</span>
            <span class="comment">%</span>
            <span class="comment">%   See also  getBlock, addBlock</span>

            <span class="comment">% Convert block structure to cell array of events</span>
            varargin=mr.block2events(varargin);

            obj.blockEvents(index,:) = zeros(1,6);
            <span class="comment">% Loop over events adding to library if necessary and creating</span>
            <span class="comment">% block event structure.</span>
            <span class="keyword">for</span> i=1:length(varargin)
                event = varargin{i};
                <span class="keyword">switch</span> event.type
                    <span class="keyword">case</span> <span class="string">'rf'</span>
                        <span class="comment">% TODO: interpolate to 1us time grid using event.t</span>

                        mag = abs(event.signal);
                        amplitude=max(mag);
                        mag = mag/amplitude;
                        phase = angle(event.signal);
                        phase(phase&lt;0)=phase(phase&lt;0)+2*pi;
                        phase=phase/(2*pi);

                        magShape = mr.compressShape(mag);
                        magId = mr.Sequence.searchLibrary(obj.shapeLibrary,magShape);
                        obj.shapeLibrary(magId) = magShape;

                        phaseShape = mr.compressShape(phase);
                        phaseId = mr.Sequence.searchLibrary(obj.shapeLibrary,phaseShape);
                        obj.shapeLibrary(phaseId) = phaseShape;

                        rf.data = [amplitude magId phaseId event.freqOffset event.phaseOffset];
                        id = mr.Sequence.searchLibrary(obj.rfLibrary,rf);
                        obj.rfLibrary(id) = rf;
                        obj.blockEvents(index,2)=id;
                    <span class="keyword">case</span> <span class="string">'grad'</span>
                        amplitude = max(abs(event.waveform));
                        g = event.waveform./amplitude;
                        shape = mr.compressShape(g);
                        shapeId = mr.Sequence.searchLibrary(obj.shapeLibrary,shape);
                        obj.shapeLibrary(shapeId) = shape;

                        grad.data = [amplitude shapeId];
                        grad.type = <span class="string">'grad'</span>;
                        id = mr.Sequence.searchLibrary(obj.gradLibrary,grad);
                        obj.gradLibrary(id) = grad;
                        obj.blockEvents(index,2+event.channel)=id;
                    <span class="keyword">case</span> <span class="string">'trap'</span>
                        grad.data = [event.amplitude event.riseTime event.flatTime event.fallTime];
                        grad.type = <span class="string">'trap'</span>;
                        id = mr.Sequence.searchLibrary(obj.gradLibrary,grad);
                        obj.gradLibrary(id) = grad;
                        obj.blockEvents(index,event.channel+2)=id;
                    <span class="keyword">case</span> <span class="string">'adc'</span>
                        adc.data = [event.numSamples event.dwell event.delay event.freqOffset event.phaseOffset];
                        id = mr.Sequence.searchLibrary(obj.adcLibrary,adc);
                        obj.adcLibrary(id) = adc;
                        obj.blockEvents(index,6)=id;
                    <span class="keyword">case</span> <span class="string">'delay'</span>
                        delay.data = [event.delay];
                        id = mr.Sequence.searchLibrary(obj.delayLibrary,delay);
                        obj.delayLibrary(id) = delay;
                        obj.blockEvents(index,1)=id;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> block = getBlock(obj,index)
            <span class="comment">%getBlock Return a block of the sequence.</span>
            <span class="comment">%   b=getBlock(obj, index) Return the block specified by the</span>
            <span class="comment">%   index.</span>
            <span class="comment">%</span>
            <span class="comment">%   The block is created from the sequence data with all</span>
            <span class="comment">%   events and shapes decompressed.</span>
            <span class="comment">%</span>
            <span class="comment">%   See also  setBlock, addBlock</span>

            block=struct(<span class="string">'rf'</span>,{},<span class="string">'gx'</span>,{},<span class="string">'gy'</span>,{},<span class="string">'gz'</span>,{},<span class="string">'adc'</span>,{},<span class="string">'delay'</span>,{});
            block(1).rf=[];
            eventInd = obj.blockEvents(index,:);

            <span class="keyword">if</span> eventInd(1)&gt;0
                delay.type = <span class="string">'delay'</span>;
                delay.delay = obj.delayLibrary(eventInd(1)).data;
                block.delay = delay;
            <span class="keyword">end</span>
            <span class="keyword">if</span> eventInd(2)&gt;0
                rf.type=<span class="string">'rf'</span>;
                libData = obj.rfLibrary(eventInd(2)).data;

                amplitude = libData(1);
                magShape = libData(2);
                phaseShape = libData(3);
                mag = mr.decompressShape(obj.shapeLibrary(magShape));
                phase = mr.decompressShape(obj.shapeLibrary(phaseShape));
                rf.signal = amplitude*mag.*exp(1j*2*pi*phase);
                rf.t = (1:length(mag))'*mr.Sequence.RfRasterTime;

                rf.freqOffset = libData(4);
                rf.phaseOffset = libData(5);

                block.rf = rf;
            <span class="keyword">end</span>
            gradChannels = {<span class="string">'gx'</span>,<span class="string">'gy'</span>,<span class="string">'gz'</span>};
            <span class="keyword">for</span> i=1:length(gradChannels)
                <span class="keyword">if</span> eventInd(2+i)&gt;0
                    type = obj.gradLibrary(eventInd(2+i)).type;
                    libData = obj.gradLibrary(eventInd(2+i)).data;
                    grad.type = type;
                    grad.channel = i;
                    <span class="keyword">if</span> strcmp(type,<span class="string">'grad'</span>)
                        amplitude = libData(1);
                        shapeId = libData(2);
                        g = mr.decompressShape(obj.shapeLibrary(shapeId));
                        grad.waveform = amplitude*g;
                        grad.t = (1:length(g))'*mr.Sequence.GradRasterTime;
                    <span class="keyword">else</span>
                        grad.amplitude = libData(1);
                        grad.riseTime = libData(2);
                        grad.flatTime = libData(3);
                        grad.fallTime = libData(4);
                        grad.area = grad.amplitude*(grad.flatTime+grad.riseTime/2+grad.fallTime/2);
                        grad.flatArea = grad.amplitude*grad.flatTime;
                    <span class="keyword">end</span>

                    block.(gradChannels{i}) = grad;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> eventInd(6)&gt;0
                libData = obj.adcLibrary(eventInd(6)).data;
                adc = cell2struct(num2cell(libData),<span class="keyword">...</span>
                    {<span class="string">'numSamples'</span>,<span class="string">'dwell'</span>,<span class="string">'delay'</span>,<span class="string">'freqOffset'</span>,<span class="string">'phaseOffset'</span>},2);
                adc.type=<span class="string">'adc'</span>;
                block.adc = adc;
            <span class="keyword">end</span>

        <span class="keyword">end</span>


        <span class="keyword">function</span> f=plot(obj,varargin)
            <span class="comment">%plot Plot the sequence in a new figure.</span>
            <span class="comment">%   plot(seqObj) Plot the sequence</span>
            <span class="comment">%</span>
            <span class="comment">%   plot(...,'Type',type) Plot the sequence with gradients</span>
            <span class="comment">%   displayed according to type: 'Gradient' or 'Kspace'.</span>
            <span class="comment">%</span>
            <span class="comment">%   plot(...,'TimeRange',[start stop]) Plot the sequence</span>
            <span class="comment">%   between the times specified by start and stop.</span>
            <span class="comment">%</span>
            <span class="comment">%   plot(...,'TimeDisp',unit) Display time in:</span>
            <span class="comment">%   's', 'ms' or 'us'.</span>
            <span class="comment">%</span>
            <span class="comment">%   f=plot(...) Return the new figure handle.</span>
            <span class="comment">%</span>

            validPlotTypes = {<span class="string">'Gradient'</span>,<span class="string">'Kspace'</span>};
            validTimeUnits = {<span class="string">'s'</span>,<span class="string">'ms'</span>,<span class="string">'us'</span>};
            <span class="keyword">persistent</span> parser
            <span class="keyword">if</span> isempty(parser)
                parser = inputParser;
                parser.FunctionName = <span class="string">'plot'</span>;
                parser.addParamValue(<span class="string">'type'</span>,validPlotTypes{1},<span class="keyword">...</span>
                    @(x) any(validatestring(x,validPlotTypes)));
                parser.addParamValue(<span class="string">'timeRange'</span>,[0 inf],@(x)(isnumeric(x) &amp;&amp; length(x)==2));
                parser.addParamValue(<span class="string">'timeDisp'</span>,validTimeUnits{1},<span class="keyword">...</span>
                    @(x) any(validatestring(x,validTimeUnits)));
            <span class="keyword">end</span>
            parse(parser,varargin{:});
            opt = parser.Results;

            fig=figure;
            <span class="keyword">if</span> nargout&gt;0
                f=fig;
            <span class="keyword">end</span>
            <span class="keyword">for</span> i=1:6
                ax(i)=subplot(3,2,i);
            <span class="keyword">end</span>
            ax=ax([1 3 5 2 4 6]);
            arrayfun(@(x)hold(x,<span class="string">'on'</span>),ax);
            arrayfun(@(x)grid(x,<span class="string">'on'</span>),ax);
            labels={<span class="string">'ADC'</span>,<span class="string">'RF mag (Hz)'</span>,<span class="string">'RF ph (rad)'</span>,<span class="string">'Gx (Hz/m)'</span>,<span class="string">'Gy (Hz/m)'</span>,<span class="string">'Gz (Hz/m)'</span>};
            arrayfun(@(x)ylabel(ax(x),labels{x}),1:6);

            tFactorList = [1 1e3 1e6];
            tFactor = tFactorList(strcmp(opt.timeDisp,validTimeUnits));
            xlabel(ax(3),[<span class="string">'t ('</span> opt.timeDisp <span class="string">')'</span>]);
            xlabel(ax(6),[<span class="string">'t ('</span> opt.timeDisp <span class="string">')'</span>]);

            t=0;
            <span class="keyword">for</span> i=1:size(obj.blockEvents,1)
                block = obj.getBlock(i);
                isValid = t&gt;=opt.timeRange(1) &amp;&amp; t&lt;=opt.timeRange(2);
                <span class="keyword">if</span> ~isempty(block.adc)
                    <span class="keyword">if</span> isValid
                        adc=block.adc;
                        tt=adc.delay + (0:adc.numSamples-1)*adc.dwell;
                        plot(tFactor*(t+tt),zeros(size(tt)),<span class="string">'rx'</span>,<span class="string">'Parent'</span>,ax(1));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> ~isempty(block.rf)
                    <span class="keyword">if</span> isValid
                        rf=block.rf;
                        tt=rf.t;
                        plot(tFactor*(t+tt),abs(rf.signal),<span class="string">'Parent'</span>,ax(2));
                        plot(tFactor*(t+tt),angle(rf.signal),<span class="string">'Parent'</span>,ax(3));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                gradChannels={<span class="string">'gx'</span>,<span class="string">'gy'</span>,<span class="string">'gz'</span>};
                <span class="keyword">for</span> j=1:length(gradChannels)
                    grad=block.(gradChannels{j});
                    <span class="keyword">if</span> ~isempty(block.(gradChannels{j}))
                        <span class="keyword">if</span> strcmp(grad.type,<span class="string">'grad'</span>)
                            tt=grad.t;
                            waveform=grad.waveform;
                        <span class="keyword">else</span>
                            tt=cumsum([0 grad.riseTime grad.flatTime grad.fallTime]);
                            waveform=grad.amplitude*[0 1 1 0];
                        <span class="keyword">end</span>

                        <span class="keyword">if</span> isValid
                            plot(tFactor*(t+tt),waveform,<span class="string">'Parent'</span>,ax(3+j));
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                t=t+mr.calcDuration(block);
            <span class="keyword">end</span>

            linkaxes(ax(:),<span class="string">'x'</span>)
            dispRange = tFactor*[opt.timeRange(1) min(opt.timeRange(2),t)];
            xlim(ax(1),dispRange);

            h = zoom;
            setAxesZoomMotion(h,ax(1),<span class="string">'horizontal'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">methods</span> (Static)

        <span class="keyword">function</span> id = searchLibrary(library,dataStruct)
            <span class="comment">%searchLibrary Lookup a data structure in the given library.</span>
            <span class="comment">%   idx=searchLibrary(lib,data) Return the index of the data in</span>
            <span class="comment">%   the library. If the data doesn't exist in the library then</span>
            <span class="comment">%   the index for the next new entry is returned.</span>
            <span class="comment">%</span>
            <span class="comment">%   The dataStruct must have a field .data with numeric valued</span>
            <span class="comment">%   array</span>
            <span class="comment">%</span>
            <span class="comment">%   See also  addBlock</span>

            found=0;
            keys=cell2mat(library.keys);
            values=library.values;
            <span class="keyword">for</span> iL=1:length(keys)
                <span class="comment">%                 data=library(keys(iL)).data;</span>
                data=values{iL}.data;
                <span class="keyword">if</span> length(data)==length(dataStruct.data) &amp;&amp; <span class="keyword">...</span>
                        norm(data-dataStruct.data)&lt;1e-6
                    id=keys(iL);
                    found=1;
                    <span class="keyword">break</span>;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(keys)
                id=1;
            <span class="keyword">elseif</span> ~found
                id=max(keys)+1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>



    <span class="keyword">end</span> <span class="comment">% Static methods</span>



<span class="keyword">end</span> <span class="comment">% classdef</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef Sequence < handle
    % Sequence   Generate sequences and read/write sequence files.
    % This class defines properties and methods to define a complete
    % MR sequence including RF pulses, gradients, ADC events, etc.
    %
    % The class provides an implementation of the open MR sequence format
    % defined by the Pulseq project.
    %   See http://pulseq.github.io/
    %
    % Sequence Properties:
    %    definitions - A list of custom definitions
    %
    % Sequence Methods:
    %    read - Load sequence from open MR sequence format
    %    write - Write sequence to open MR sequence format
    %
    % Sequence Static Methods:
    %    makeTrapezoid - Create a trapezoid gradient structure
    %
    % Examples:
    %
    % To read a sequence from file:
    %     read(seqObj,'my_sequences/gre.seq');
    %
    % To plot a sequence:
    %     plot(seqObj)
    %
    % See also   demoRead.m, demoWrite.m
    % Examples defining an MRI sequence and reading/writing files
    %
    % Kelvin Layton <kelvin.layton@uniklinik-freiburg.de>
    
    properties(Constant)
        RfRasterTime = 1e-6;
        GradRasterTime = 10e-6;
    end
    
    % Private properties
    %
    properties(GetAccess = public, SetAccess = private)
        definitions     % Optional sequence definitions
        
        blockEvents;    % Event table (references to events)
        rfLibrary;      % Library of RF events
        gradLibrary;    % Library of gradient events
        adcLibrary;     % Library of ADC readouts
        delayLibrary;   % Library of delay events
        shapeLibrary;   % Library of compressed shapes
    end
    
    methods
        
        function obj = Sequence()
            obj.definitions=containers.Map();
            obj.gradLibrary=containers.Map('KeyType','double','ValueType','any');
            obj.shapeLibrary=containers.Map('KeyType','double','ValueType','any');
            obj.rfLibrary=containers.Map('KeyType','double','ValueType','any');
            obj.adcLibrary=containers.Map('KeyType','double','ValueType','any');
            obj.delayLibrary=containers.Map('KeyType','double','ValueType','any');
        end
        
        % See read.m
        read(obj,filename)
        
        % See write.m
        write(obj,filename)
        
        function value=getDefinition(obj,key)
            %getDefinition Return the values of custom definition.
            %   val=getDefinitions(seqObj,key) Return value of the
            %   definition specified by the key.
            
            %   These definitions can be added manually or read from the
            %   header of a sequence file defined in the sequence header.
            %   An empty array is return if the key is not defined.
            %
            %   See also setDefinition
            if isKey(obj.definitions,key)
                value = obj.definitions(key);
            else
                value = [];
            end
        end
        
        function setDefinition(seqObj,key,val)
            %setDefinition Modify a custom definition of the sequence.
            %   setDefinition(seqObj,def,val) Set the user definition 'key'
            %   to value 'val'. If the definition does not exist it will be
            %   created.
            %
            %   See also getDefinition
            seqObj.definitions(key)=val;
        end
        
        function addBlock(obj,varargin)
            %addBlock Add a new block to the sequence.
            %   addBlock(obj, blockStruct) Adds a sequence block with
            %   provided as a block struture
            %
            %   addBlock(obj, e1, e2, ...) Adds a block with multiple
            %   events e1, e2, etc.
            %
            %   See also  setBlock, makeAdc, makeTrapezoid, makeSincPulse
            setBlock(obj,size(obj.blockEvents,1)+1,varargin{:});
            
        end
        
        %TODO: replacing blocks mid sequence can cause library indexing
        %issues, no longer run in order (ok?), unused library entries (can prune).
        function setBlock(obj,index,varargin)
            %setBlock Replace sequence block.
            %   setBlock(obj, index, bStruct) Replace block at index with new
            %   block provided as block structure.
            %
            %   setBlock(obj, index, e1, e2, ...) Create a new block from
            %   events and store at position given by index.
            %
            %   The block or events are provides in uncompressed form and
            %   will be stored in a compressed, non-redundant internal
            %   libraries.
            %
            %   See also  getBlock, addBlock
            
            % Convert block structure to cell array of events
            varargin=mr.block2events(varargin);
            
            obj.blockEvents(index,:) = zeros(1,6);
            % Loop over events adding to library if necessary and creating
            % block event structure.
            for i=1:length(varargin)
                event = varargin{i};
                switch event.type
                    case 'rf'
                        % TODO: interpolate to 1us time grid using event.t
                        
                        mag = abs(event.signal);
                        amplitude=max(mag);
                        mag = mag/amplitude;
                        phase = angle(event.signal);
                        phase(phase<0)=phase(phase<0)+2*pi;
                        phase=phase/(2*pi);
                        
                        magShape = mr.compressShape(mag);
                        magId = mr.Sequence.searchLibrary(obj.shapeLibrary,magShape);
                        obj.shapeLibrary(magId) = magShape;
                        
                        phaseShape = mr.compressShape(phase);
                        phaseId = mr.Sequence.searchLibrary(obj.shapeLibrary,phaseShape);
                        obj.shapeLibrary(phaseId) = phaseShape;
                        
                        rf.data = [amplitude magId phaseId event.freqOffset event.phaseOffset];
                        id = mr.Sequence.searchLibrary(obj.rfLibrary,rf);
                        obj.rfLibrary(id) = rf;
                        obj.blockEvents(index,2)=id;
                    case 'grad'
                        amplitude = max(abs(event.waveform));
                        g = event.waveform./amplitude;
                        shape = mr.compressShape(g);
                        shapeId = mr.Sequence.searchLibrary(obj.shapeLibrary,shape);
                        obj.shapeLibrary(shapeId) = shape;
                        
                        grad.data = [amplitude shapeId];
                        grad.type = 'grad';
                        id = mr.Sequence.searchLibrary(obj.gradLibrary,grad);
                        obj.gradLibrary(id) = grad;
                        obj.blockEvents(index,2+event.channel)=id;
                    case 'trap'
                        grad.data = [event.amplitude event.riseTime event.flatTime event.fallTime];
                        grad.type = 'trap';
                        id = mr.Sequence.searchLibrary(obj.gradLibrary,grad);
                        obj.gradLibrary(id) = grad;
                        obj.blockEvents(index,event.channel+2)=id;
                    case 'adc'
                        adc.data = [event.numSamples event.dwell event.delay event.freqOffset event.phaseOffset];
                        id = mr.Sequence.searchLibrary(obj.adcLibrary,adc);
                        obj.adcLibrary(id) = adc;
                        obj.blockEvents(index,6)=id;
                    case 'delay'
                        delay.data = [event.delay];
                        id = mr.Sequence.searchLibrary(obj.delayLibrary,delay);
                        obj.delayLibrary(id) = delay;
                        obj.blockEvents(index,1)=id;
                end
            end
        end
        
        function block = getBlock(obj,index)
            %getBlock Return a block of the sequence.
            %   b=getBlock(obj, index) Return the block specified by the
            %   index.
            %
            %   The block is created from the sequence data with all
            %   events and shapes decompressed.
            %
            %   See also  setBlock, addBlock
            
            block=struct('rf',{},'gx',{},'gy',{},'gz',{},'adc',{},'delay',{});
            block(1).rf=[];
            eventInd = obj.blockEvents(index,:);
            
            if eventInd(1)>0
                delay.type = 'delay';
                delay.delay = obj.delayLibrary(eventInd(1)).data;
                block.delay = delay;
            end
            if eventInd(2)>0
                rf.type='rf';
                libData = obj.rfLibrary(eventInd(2)).data;
                
                amplitude = libData(1);
                magShape = libData(2);
                phaseShape = libData(3);
                mag = mr.decompressShape(obj.shapeLibrary(magShape));
                phase = mr.decompressShape(obj.shapeLibrary(phaseShape));
                rf.signal = amplitude*mag.*exp(1j*2*pi*phase);
                rf.t = (1:length(mag))'*mr.Sequence.RfRasterTime;
                
                rf.freqOffset = libData(4);
                rf.phaseOffset = libData(5);
                
                block.rf = rf;
            end
            gradChannels = {'gx','gy','gz'};
            for i=1:length(gradChannels)
                if eventInd(2+i)>0
                    type = obj.gradLibrary(eventInd(2+i)).type;
                    libData = obj.gradLibrary(eventInd(2+i)).data;
                    grad.type = type;
                    grad.channel = i;
                    if strcmp(type,'grad')
                        amplitude = libData(1);
                        shapeId = libData(2);
                        g = mr.decompressShape(obj.shapeLibrary(shapeId));
                        grad.waveform = amplitude*g;
                        grad.t = (1:length(g))'*mr.Sequence.GradRasterTime;
                    else
                        grad.amplitude = libData(1);
                        grad.riseTime = libData(2);
                        grad.flatTime = libData(3);
                        grad.fallTime = libData(4);
                        grad.area = grad.amplitude*(grad.flatTime+grad.riseTime/2+grad.fallTime/2);
                        grad.flatArea = grad.amplitude*grad.flatTime;
                    end
                    
                    block.(gradChannels{i}) = grad;
                end
            end
            if eventInd(6)>0
                libData = obj.adcLibrary(eventInd(6)).data;
                adc = cell2struct(num2cell(libData),...
                    {'numSamples','dwell','delay','freqOffset','phaseOffset'},2);
                adc.type='adc';
                block.adc = adc;
            end
            
        end
        
        
        function f=plot(obj,varargin)
            %plot Plot the sequence in a new figure.
            %   plot(seqObj) Plot the sequence
            %
            %   plot(...,'Type',type) Plot the sequence with gradients
            %   displayed according to type: 'Gradient' or 'Kspace'.
            %
            %   plot(...,'TimeRange',[start stop]) Plot the sequence
            %   between the times specified by start and stop.
            %
            %   plot(...,'TimeDisp',unit) Display time in:
            %   's', 'ms' or 'us'.
            %
            %   f=plot(...) Return the new figure handle.
            %
            
            validPlotTypes = {'Gradient','Kspace'};
            validTimeUnits = {'s','ms','us'};
            persistent parser
            if isempty(parser)
                parser = inputParser;
                parser.FunctionName = 'plot';
                parser.addParamValue('type',validPlotTypes{1},...
                    @(x) any(validatestring(x,validPlotTypes)));
                parser.addParamValue('timeRange',[0 inf],@(x)(isnumeric(x) && length(x)==2));
                parser.addParamValue('timeDisp',validTimeUnits{1},...
                    @(x) any(validatestring(x,validTimeUnits)));
            end
            parse(parser,varargin{:});
            opt = parser.Results;
            
            fig=figure;
            if nargout>0
                f=fig;
            end
            for i=1:6
                ax(i)=subplot(3,2,i);
            end
            ax=ax([1 3 5 2 4 6]);
            arrayfun(@(x)hold(x,'on'),ax);
            arrayfun(@(x)grid(x,'on'),ax);
            labels={'ADC','RF mag (Hz)','RF ph (rad)','Gx (Hz/m)','Gy (Hz/m)','Gz (Hz/m)'};
            arrayfun(@(x)ylabel(ax(x),labels{x}),1:6);
            
            tFactorList = [1 1e3 1e6];
            tFactor = tFactorList(strcmp(opt.timeDisp,validTimeUnits));
            xlabel(ax(3),['t (' opt.timeDisp ')']);
            xlabel(ax(6),['t (' opt.timeDisp ')']);
            
            t=0;
            for i=1:size(obj.blockEvents,1)
                block = obj.getBlock(i);
                isValid = t>=opt.timeRange(1) && t<=opt.timeRange(2);
                if ~isempty(block.adc)
                    if isValid
                        adc=block.adc;
                        tt=adc.delay + (0:adc.numSamples-1)*adc.dwell;
                        plot(tFactor*(t+tt),zeros(size(tt)),'rx','Parent',ax(1));
                    end
                end
                if ~isempty(block.rf)
                    if isValid
                        rf=block.rf;
                        tt=rf.t;
                        plot(tFactor*(t+tt),abs(rf.signal),'Parent',ax(2));
                        plot(tFactor*(t+tt),angle(rf.signal),'Parent',ax(3));
                    end
                end
                gradChannels={'gx','gy','gz'};
                for j=1:length(gradChannels)
                    grad=block.(gradChannels{j});
                    if ~isempty(block.(gradChannels{j}))
                        if strcmp(grad.type,'grad')
                            tt=grad.t;
                            waveform=grad.waveform;
                        else
                            tt=cumsum([0 grad.riseTime grad.flatTime grad.fallTime]);
                            waveform=grad.amplitude*[0 1 1 0];
                        end
                        
                        if isValid
                            plot(tFactor*(t+tt),waveform,'Parent',ax(3+j));
                        end
                    end
                end
                t=t+mr.calcDuration(block);
            end
            
            linkaxes(ax(:),'x')
            dispRange = tFactor*[opt.timeRange(1) min(opt.timeRange(2),t)];
            xlim(ax(1),dispRange);
            
            h = zoom;
            setAxesZoomMotion(h,ax(1),'horizontal');
        end
    end
    methods (Static)
        
        function id = searchLibrary(library,dataStruct)
            %searchLibrary Lookup a data structure in the given library.
            %   idx=searchLibrary(lib,data) Return the index of the data in
            %   the library. If the data doesn't exist in the library then
            %   the index for the next new entry is returned.
            %
            %   The dataStruct must have a field .data with numeric valued
            %   array
            %
            %   See also  addBlock
            
            found=0;
            keys=cell2mat(library.keys);
            values=library.values;
            for iL=1:length(keys)
                %                 data=library(keys(iL)).data;
                data=values{iL}.data;
                if length(data)==length(dataStruct.data) && ...
                        norm(data-dataStruct.data)<1e-6
                    id=keys(iL);
                    found=1;
                    break;
                end
            end
            if isempty(keys)
                id=1;
            elseif ~found
                id=max(keys)+1;
            end
        end
        
        
        
    end % Static methods
    
    
    
end % classdef

##### SOURCE END #####
--></body></html> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.9.1
</small></address>
</body>
</html>
